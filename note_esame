Note metodologiche:
    1) Pre e post condizioni dell'uc dettagliato descrivono lo stato del business, mentre quelle dei contratti
    descrivono lo stato del sistema, ragion per cui alle volte differiscono (es. nell'uc gestione eventi una
    pre-condizione è l'esistenza di un evento assegnato all'organizzatore, mentre nei contratti questa non
    è una pre-condizione generale, perchè magari all'interno del business l'organizzatore ha già
    ricevuto l'incarico, ma la scheda dell'evento, che consente di verificare ciò, non è ancora stata creata).
    
    2) Le eccezioni servono a rappresentare le violazioni della logica di business.

**** UC GESTIONE COMPITI ****

1) Una preparazione può NON essere associata ad alcuna ricetta. Ricetta e preparazione sono concetti COLLEGABILI, ma non per forza collegati.

2) Ho tolto la possibilità di terminare l'uc subito dopo il primo passo: in effetti la user story che sembrava richiedere ciò ci dice che lo chef
può fermarsi prima delle assegnazioni, non dice nulla sull'aggiunta di ricette fuori menù.
A più senso fare così, in modo da racchiudere in unico blocco le operazioni correlate.

3) Non c'è la possibilità di segnare il compito come completato, perchè il testo dice che a farlo è il cuoco.

4) Ho deciso di usare "termina il caso d'uso" come continuazione per la maggior parte delle eccezioni.
In effetti, non ha molto senso complicarsi troppo la vita e soprattutto alle volte potrebbe non essere chiaro
il motivo per cui si sta ripetendo: ad esempio, nella ecceione 1.1b di gestione compiti "Ripete il passo 1" potrebbe
voler dire riprovare a creare il foglio per lo stesso servizio, cosa evidentemente inutile, visto che esiste già.
Con condizioni più raffinate, tipo "torna al passo 5 e sceglie un altro compito" si rischia di complicare tutto il resto
e di non poterle verificare (come fai a controllare che abbia scelto un altro compito? Certo, qualora non fosse così
incapperebbe in un altro errore, ma non ha molto senso).
Le cose di prima non erano sbagliate, però ci portano ad un applicativo non minimale, perchè anche terminare e riprendere
produce lo stesso effetto.


6) Relazione compito-ricetta: un compito contiene, come mansioni da svolgere al suo interno, la ricetta e tutte le preparazioni suoi ingredienti.
NO, Ogni mansione di cucina è svolta in un compito diverso.
Questo induce la necessità di recuperare le mansioni che compongono un menù. Ora, questo si potrebbe fare scorrendo le ricette che formano
il menù e recuperando le mansioni loro ingrendienti, però è lento e scomodo da realizzare nei dsd, quindi conviene un'associazione derivabile.
Quindi in questa associazione mettiamo solo le ricette oppure anche gli ingredienti ??? (*)
In caso affermativo, ci sarà una lista lato menù con i riferimenti alle mansioni.
ALtrimenti, il menù avrà una lista di ricette, ciascuna delle quali possiederà un elenco delle mansioni suoi ingredienti.

Probabilmente conviene la seconda soluzione, perchè ha granularità più fine, e consente di recuperare anche soltanto le ricette, senza ingredienti

7) Al passo 5, bisogna anche controllare che il compito sia da svolgere e non completato??
No, il completamento del compito riguarda un altro uc, quindi per il momento possiamo ometterlo.

8) Le estensioni di modifica sono inutilmente complicate: se l'utente vuole cambiare qualcosa cancella e ricrea, così
noi abbiamo un applicativo minimale.

9) "Il compito scelto non fa parte del foglio riepilogativo su cui si sta lavorando" non è un'eccezzione molto sensata.
Infatti, è improbabile che il sistema mostri anche i compiti che non fanno parte del foglio su cui si sta lavorando (più che altro
non ne avrebbe motivo), quindi questo errore non può proprio verificarsi.

10) Vedere questione della cucina satura: in effetti la saturazione della cucina, cioè il completamento del compito, è da fare qui (vedi punto 13).

11) Impediamo l'inserimento di dettagli per compiti non da preparare/già completati: in quei casi infatti le indicazioni relative
allo svolgimento non hanno senso, proprio perchè i compiti non sono da svolgere.

12) Ho tolto la modifca e l'eliminazione delle stime e delle quantità.
Queste vengono inserite NON autonomamente, ma solo in fase di assegnazione, dove in effetti non ha molto senso che si vadano ad eliminare
o modificare

13) La gestione della saturazione del turno conviene trattarla come estensione del passo 5, dato che essa dipende dai compiti assegnati al turno, operazione
in effetti svolta al passo 5

16) Valutare se serva l'associazione chef - possesso - foglio: forse serve per la verifica dei permessi.
Non serve, basta controllare lo chef assegnato all'evento a cui fa riferimento il servizio.

17) Un compito viene svolto in un unico turno e prevede attività su di un'unica mansione

18) Le uniche mansioni di cucina a poter fare da ingrendiente sono le preparazioni.

19) Vedere se la proposta di modifica vada collegata alla voce del menù: potrebbe essere più facile gestirne inserimento e cancellazione (*)

20) Lo chef deve poter specificare che il compito vada preparato ma anche il contrario, quindi è meglio che quello diventi un passo indipendente
(non ci sono nemmeno motivi per tenerlo come estensione del passo 5).

21) Il parametro compito nel passo due dell'ssd di gestione compiti serve ad indicare il compito di cui è continuazione quello appena creato.

22) Granularità dell'UC Dettagliato: deve essere abbastanza specifico da poter evincere, da esso, le seguenti informazioni:
    -operazioni dell'ssd, con relativi parametri
    -entità del modello di dominio, con annesse proprietà
    
    
23) Valore di default di "Da preparare": ha senso preimpostarlo a sì, in fin dei conti, il sistema deve automatizzare il più possibile e qui
la maggior parte dei compiti avrà si come valore di questo attributo. Quindi l'attributo non è più opzionale.
Discorso diverso per quantità e tempistiche, dove non esiste un valore di default.

24) Non ha senso mettere evento e menù come parametri di crea generaFoglioRiepilogativo: possono essere inferiti automaticamente dal servizio
e non è logico che l'utente li specifichi, perchè il foglio riepilogativo è un concetto associato al servizio.

25) Compiti presenti nel foglio riepilogativo: Di base, viene creato un compito per ogni mansione
di cucina presente (direttamente oppure come ingrediente) nel menù scelto per il servizio.
Tali compiti non si possono eliminare: al massimo sono contrassegnabili come da non preparare (semplicemente perchè
nel testo tale operazione non è mai menzionata).
AL passo 2, è possibile creare un compito corrispondente ad una mansione non presente nel menù.
Esso può essere eliminato con l'estensione del passo 2.

26) Se un compito è già pronto (da preparare = no) allora:
    -non posso assegnarlo
    -quindi non posso nemmeno eliminare l'assegnazione
    -però posso eliminarlo (magari non voglio più offrirlo durante il servizio: non è ragionevole impedire ciò solo perchè è già pronto)
    -non posso modificarne i dettagli (ha senso, magari sono già pronte 10 porzioni. Se io modifico la stime delle porzioni necessarie
    in 15 non è vero che il compito non è più da preparare ed il sistema diventa inconsistente).


DCD e DSD: 
    
27) "Ingrediente in" è tra preparazione e mansione perchè una preparazione può essere ingrediente di un'altra preparazione.
Di conseguenza, il metodo getPreparation è presente in qualsiasi mansione di cucina.
Invece "ingredients", nel dcd, è un collegamento tra ricetta e preparazione perchè gli ingredienti di ricette possono essere solo preparazioni

28) Ho deciso di togliere le entità che dettagliavano i vari tipi di utenti dal dsd: in alcuni casi sono inutili, in altri servono solo
perchè implementavano il collegamento con una lista, cosa però non obbligatoria e troppo complicata.
Quindi implementiamo i collegamenti 1-n con il campo singolo dal lato n.
GIUSTIFICARE BENE QUESTA COSA. Motivi vari:
    -modellazione più naturale: ad esempio, l'evento è più importante del menù, quindi ha più senso
    che sia il primo ad avere un riferimento al secondo, ed in effetti questa è la prima solzuione che viene in mente
    
    -soluzione più efficiente: supponendo che la lista venga implementata con array list, la complessità del contains è O(n),
    contando che con questa soluzione si fanno tantissime contains il codice è poco efficiente.
    Con l'attributo i controlli, come l'assegnazione dell'evento allo chef, si fanno in tempo costante.
    Un'esempio di operazione che diventa molto più semplice è l'update del task: nella versione con lista bisogna
    cercarlo, toglierlo dalla lista, modificarlo ed infine reinserirlo. Insomma tutto troppo lungo.
    
    -dsd e codice più semplice

29) Cercare i doppi riferimenti (*)
Evento-Servizio è un doppio riferimento: serve per velocizzare alcune operazioni, ad esempio:
    -il recupero dell'evento assegnato ad un servizio, necessario per fare controlli iniziali come il fatto
    che lo chef stiamo modificando un servizio assegnatogli

Occorrenza-Evento capofila ha un doppio riferimento. Senza, per recuperare il capofila data un'occorrenza, dovremmo
scorrere l'elenco degli eventi capofila e, per ciascuno, scorrere la lista delle occorrenze.
Tutto ciò sarebbe molto lento, quindi conviene sprecare un po' di spazio, inserendo nell'occorrenza un
riferimento al capofila, anche considerando che lo spazio è oggi più economico del tempo di calcolo.

Disponibilità-Evento: stesso ragionamento di sopra, per recuperare il personale fatto per un evento, operazione
necessaria per liberarlo, dovremmo scorrere tutto l'elenco delle prenotazioni, che, soprattutto se decidessimo
di mantenere lo storico, potrebbe essere lunghissimo.
In più, questa operazione è piuttosto frequente negli annullamenti di servizi/eventi, quindi il costo è facile da ammortizzare.


30) La disponibilità viene spostata nel turno, perchè non ha senso mantenerla a parte. L'unico uc che le gestisce parla in realtà
di "contrassegnare i turni", ed in effetti la disponibilità non ha senso senza turno

31) Non ho messo il client che commissiona l'evento: non è utile in questi UC, inserendolo il dcd diventerebbe una copia del modello di dominio

32) In alcuni punti usiamo le classi abstract e non le interfaccie perchè le ultime non possono avere attributi

33) Ho rimosso alcune notify/update: se non c'è nulla da salvare su db non servono

34) Il foglio riepilogativo su cui si lavora viene settato durante creazione/apertura (quindi al passo 1)

35) I parametri di update e notify sono gli oggetti che abbiamo modificato durante l'operazione e di cui vogliamo
notificare il cambiamento di stato (per poterli memorizzare)

36) Per noi il foglio riepilogativo è la collezione di compiti associati ad un servizio, quindi consideriamo il foglio aperto/apribile
se il servizio corrente è non nullo ed ha almeno un compito. In pratica la condizione "è in corso la gestione dei compiti
relativi ad un foglio riepilogativo f" viene modellata come  [currentService != NULL && currentService.assignments != NULL]

37) Vedere cosa restituire nei dsd (**): restituiamo l'oggetto modificato?
Sì, attenzione però a non restituire oggetti già noti (nella prima operazione, ad esempio, seguendo
questa logica dovremmo restituire il servizio, che però era già noto a tutti, quindi non restituiamo nulla
(qui infatti non si crea niente, modifichiamo una copia condivisa)

38) Chi può prenotare il personale di servizio ?
Sia organizzatore che chef.

39) Relazione turno-disponibilità: forse conviene il doppio riferimenti (per svolgere in tempi
ragionevoli le operazioni di ambo gli UC) (*)

40) Vedere come verificare la disponibilità del cuoco nel dsd 5 (*)

41) Vedere come implementare sgancio da compito prosecuzione in dsd 2.a.
È sufficiente osservare che in tal contesto eliminare significa sganciare dal foglio riepilogativo.

42) Sostituire tutti gli accessi a proprietà private della classe con chiamate a metodi getter e setter
(come si fa con il recupero dell'evento associato al servizio nel dsd 1) (ovviamente da questo discorso
sono esclusi gli accessi fatti dalla classe stessa: quelli sono legali).
Le chiamate a metodi getter e setter sono auto-esplicative: per evitare di rendere il dsd illeggibile le scriviamo in forma
compatta, cioè come oggetto.getx(), invece di rappresentare tutta l'interazione tra oggetti

43) Ricontrollare l'ssd, verificando che l'utente disponga delle informazioni da fornire al sistema

44) Passo 2: predisponiamo automaticamente un compito per ogni ingrediente della mansione indicata dall'utente, questo perchè
gli ingredienti vanno sicuramente indicati nel foglio riepilogativo; magari sono già pronti, però bisogna sapere quanti servirne.
In fase di cancellazione invece non li eliminiamo automaticamente, perchè non è detto che cancellare un compito implichi
l'inutilità di tutti i suoi ingredienti.

Note per discussione:

Usare le slide di Polato, sono abbastanza riassuntive

33) Vedere cosa convenga fare con gli eventi: ha senso mettere due classi diverse, una per quello semplice ed una per quello composto?

34) Esempio di note finali:
    -il menù è piaciuto/non piaciuto
    -il personale era troppo poco
    (Insomma quanto citato nella user story di Viola)


**** UC GESTIONE EVENTI ****
1) L'evento è complesso quando si estende su più giorni. Il servizio occupa sempre un solo giorno.

2) Sia lo chef che l'organizzatore possono prenotare cuochi e personale, per tipologie di turni diversi

3) L'evento in corso può essere soltanto eliminato ma non annullato. Deve esserci la possibilità di modificare/annullare anche 
solo il singolo servizio.

4) La modifica di un elemento della ricorrenza viene propagata a tutti gli elementi della ricorrenza ancora modificabili

5) Un'istanza, anche se modificata, rimane comunque parte della ricorrenza.

6) Evento.tipologia può assumere valori come "elegante", "informale", "aziendale", "privato"

7) Aggiunta dei servizi
Da testo e user stories non emerge come un passo indipendente, cioè non c'è alcuna indicazione del tipo "prima compilo la scheda, poi
aggiungi i servizi". Di fatto il servizio viene trattato come tutte le altre informazioni fornite al passo 1.
Allo stesso tempo, si tratta di un'informazione più complessa e potremmo voler associare più d'un servizio allo stesso evento.
Per questa ragione, scorporiamo la creazione dell'evento in un passo indipendente, il secondo.
Bisogna altresì notare che in un'implementazione ragionevole le due operazioni avverrebbero una dopo l'altra, senza dare all'utente
l'idea di star eseguendo un passo diverso. GIUSTIFICARE BENE (*)

8) Non c'erano motivi per terminare il caso d'uso dopo il passo 2

9) Passo 5: il singolo evento diventa "in corso" appena ne viene approvato il singolo menù. Se viene cancellato l'evento
capofila, la prima occorrenza in corso diventa capofila? Oppure cancelliamo tutta la ricorrenza?

10) Passi 4, 5, 6: delle tante formulazioni possibili di questa sequenza, abbiamo scelto questa, aderente a quanto
descritto da Viola, perchè consente di riservare subito il personale che si presume utile per il servizio, senza
dover aspettare la proposta del menù, che potrebbe arrivare magari dopo molto tempo, durante il quale i membri
del personale necessari vengono prenotati da altri.
Ad ogni modo, tutti i passi sono opzionali, quindi possiamo riprodurre anche la formulazione di Pierpaolo (prima aspetto
il menù, e solo dopo prenoto il personale).
Il salto "Ripete a partire dal passo 4 e fino alla selezione di tutto il personale desiderato" alla fine del passo 6
serve proprio a questo: possiamo prenotare altro personale, oppure liberare quello in eccedenza, dopo la scelta del menù
e l'assegnazione dei ruoli.

11) Passo 5: per ora supponiamo che l'approvazione del menù dia il via all'evento, anche se elemento di
una ricorrenza. Poi indagheremo se serva legare l'avvio degli eventi al capofila

12) Per quanto riguarda le eccezioni, la cosa più semplice è sempre terminare il caso d'uso, anche perchè non ci sono
molti motivi per fare diversamente.

13) In fase di modellazione, identifichiamo la scheda dell'evento con l'entità evento,
perchè la prima è una vista del secondo, che include le sue informazioni ed i suoi servizi.



15) Per ora rimaniamo fedeli a quanto fatto fin ora: consentiamo soltanto creazione ed eliminazione, ma non modifica.
Qui avrebbe senso fare un'eccezione solo perchè non è detto che io possa eliminare un evento (perchè in corso).
Ho comunque la possibilità di annullarlo e crearne un'altro corretto. Non vorrei mettere la modifica
perchè è un'operazione veramente troppo complessa.
L'unica eccezione è la modifica delle informazioni della ricorrenza, esplicitamente richiesta dal testo.
    
Ulteriore variazione: così è troppo restrittivo. Alcune informazioni (tipo la descrizione) si possono modificare senza difficoltà.
Vietiamo la modifica, ad evento in corso, delle informazioni sulla ricorrenza e della data degli eventi.
Per quanto riguarda la data, vale il discorso fatto prima: l'evento diventerebbe inutile e l'implementazione è troppo complicata.
Per le informazioni sulla ricorrenza, c'è il rischio di inconsistenze (ad esempio, 5 occorrenze con un periodo e 5 con un altro)
mentre la cancellazione delle occorrenze in sovrapiù andrebbe fatta solo per le occorrenze non ancora in corso, e sarebbe un casino. (*)

16) Modifica del numero di partecipanti: avrebbe senso implementarla per garantire il rispetto della business rule, che però viene
menzionata solo da una user story, quindi si può anche ignorare.

17) Eliminazione/Avvio degli eventi ricorrenti:
Per quanto concerne l'avvio, non ha senso che l'avvio dell'occorrenza i-esima sia legato a quello delle occorrenze precedenti/successive
(ad, esempio, non ha senso che per dichiarare in corso l'occorrenza di settembre io debba dichiarare in corso anche quella di dicembre, e viceversa).
Tutto ciò deve però integrarsi con il fatto che io non posso eliminare un evento ricorrente di cui ho già fatto alcune giornate.
La soluzione è trattare la ricorrenza come un blocco unico, che viene considerato in corso quando almeno uno delle sue occorrenze lo è.
A quel punto, non è più eliminabile, ma posso ovviamente annullarlo (che nello scenario di prima è la cosa più sensata, perchè
consente di rinunciare alle occorrenze ancora in programma senza cancellare quelle già passate).
In pratica, la singola occorrenza viene trattata come un qualsiasi altro evento:
    -se non è ancora in corso, indipendentemente dalle altre, può essere eliminata (non avrebbe senso
    far pagare la penale all'utente per qualcosa che non ho ancora organizzato)
    
    -se è in corso può solo essere annullata


18) Non c'è un'operazione di annullamento, perchè si tratta di una modifica particolare, che il sistema fa automaticamente quando
l'evento da eliminare è in corso.

19) Rimandare l'evento: per ora non lo includiamo, perchè è citata da una sola user story, anche perchè per non complicare
troppo l'implementazione bisognorebbe cancellare il personale, lo chef, i compiti assegnati, il foglio riepilogativo
e così via (rimarrebbero soltanto le informazioni generali): tanto vale ricreare l'evento da capo.

20) Modifica del servizio: anche qui, consentirei tutto tranne la modifica della data.
Il problema è sempre il solito, modificando data e menù, dovremmo cancellare un sacco di collegamenti.
Questo, oltre ad essere complicato, renderebbe l'evento risultato ben poco utile (cioè se liberiamo
il personale dobbiamo togliere anche le eventuali assegnazioni di compiti)

21) L'evento sui cui lavorare nel prosieguo nel dsd è fissato al passo 1.

22) Ho tolto le date dall'evento: quella è un'informazione che ha senso per il servizio, relativamente all'evento dice la stessa cosa (evento semplice)
oppure nulla di utile (evento ricorrente).
Però, per tenere traccia di "quanto lavoro" richieda un evento, ho aggiunto la durata ed il numero di servizi.
La durata indica il numero di giorni richiesti dall'evento (es. per un evento che prevede due servizi al giorno e dura 5 giorni, avremo durata = 5, e numero servizi = 10)

23) Ricordare che un servizio dura un giorno solo, mentre nella stessa giornata si possono fare più servizi.

24) Gestione della disponibilità: un oggetto disponibilità viene creato quando un membro del personale si rende disponibile a lavorare in un certo turno.
Quindi tale oggetto nasce già agganciato ad un turno, mentre viene agganciato ad un servizio solo a seguito della prenotazione da parte di uno chef/organizzatore.
Non serve quindi alcun flag prenotato: la stessa informazione è deducibile verificando se esista un servizio collegato alla disponibilità.

25) Il commento della proposta di modifica indica cosa fare con la ricetta associata (es. eliminarla, cambiare un ingrediente, ecc...)

26) Servizio.FasciaOraria è una nota testuale che potrebbe contenere valori come “9-12” per indicare un servizio che inizia alle 9 e finisce alle 12.

27) La data di inizio è specificata dall'utente. Diciamo che non è molto chiaro come procedere, nessuna delle due soluzioni (data scelta dall'utente
ed assenza di data) hanno pienamente senso. Scegliamo questo, giusto perchè non ha moolto senso memorizzare un evento senza sapere quando
inizia e perchè viene menzionato l'inserimento, da parte dell'utente, della data, e così possiamo rinviare in blocco tutto l'evento.

28) L'associazione evento capofila-occorrenza deve essere ordinata, per consentire cose come il calcolo della data di inizio, che hanno
bisogno di poter parlare di i-esima occorrenza.

29) Una proposta di modifica può fare riferimento anche a ricette che non fanno parte del menù del servizio, ad esempio per richiederne l'aggiunta.

30) L'elenco del personale, necessario al passo 3, viene verosimilmente recuperato tramite quanto offerto dall'uc "gestione del personale" oppure "gestione turni"

31) Creazione evento ricorrente: ho scelto di non mettere la verifica della mutua eclusione di periodo e data di fine come eccezione, perchè è difficile immaginare
come l'ui possa vietare di selezionare entrambe le cose (l'utente deve vedere la possibilità di inserire entrambe le informazioni).
In sostanza, lo specificarle entrambe è più un utilizzo errato del software che una vìolazione della logica di business.

32) I servi propagati, di base, si ripetono con lo stesso periodo degli eventi della ricorrenza

33) Ho deciso di non cancellare il foglio riepilogativo quando si elimina il servizio: non è un'operazione di questo uc, ed in gestione compiti non
c'è perchè s'era detto di non metterla.

34) Nel nostro applicativo valgono le seguenti regole
    -su un evento in fase di creazione si può far qualsiasi cosa
    
    -su un evento in corso il sistema consente tutte le operazioni e sta poi alla singola azienda valutare l'applicazione di penali
    (la penale non si sembrava un elemento così condiviso da poterlo inserire dell'uc dettagliato)
    
    -un un evento terminato oppure annulato non si può far nulla, se non cambiare note finali e/o documentazione
    
35) I servizi associati ad un evento vengono eliminati anche se ques'ultimo viene soltanto annullato (ragione in più per consentire anche la cancellazione
di servizi in corsi), perchè ci serve comunque un modo per segnalare che non vadano svolti. Si potrebbe pensare di introdurre il concetto di annullamento
anche per essi, ma non viene citato da nessuna parte, quindi non so quanto abbia senso.

36) Se viene eliminato (se viene annullato invece non vale, perchè le informazioni relative alla ci sono ancora). il capofila prendiamo come nuovo capofila la prima occorrenza, ragion per cui l'associazione "composto da" tra evento capofila
ed occorrenza deve essere ordinata. Questo perchè le informazioni relative alla ricorrenza sono contenute nell'istanza di evento ricorrente.

37) Rimandare un evento vuol dire traslarne tutti i servizi dello stesso numero di giorni.
Rimandare un evento capofila vuol dire traslarne le occorrenze.

38) Al di fuori di questo business, ha senso specificare sia data di fine ricorrenza che numero di occorrenze, quindi si tratta di una regola di business
quindi va imposta come eccezione.

39) Lo specificare il numero di occorrenze per un evento non ricorrente invece non è mai valido, non è qualcosa che dipende dal singolo business, quindi
va segnalato con errori a livello di post-condizioni.

40) Errori a livello di post-condizioni: li ho comunque tradotti con eccezioni, perchè l'utente deve sapere di aver utilizzato male
il software e che, quindi, il risultato non sarà quello atteso.





Cose che deve poter fare l'organizzatore
-dettaglio evento, tramit costruzione scheda

-scelta chef

-prenotazione personale. Il personale viene prenotato per un turno di servizio associato all'evento.

-indicazione ruolo

-approvazione menù/proposta modifiche a menù scelto da chef.
Probabilmente la cosa più sensata è dichiarare il singolo evento "in corso" appena ne viene approvato il menù, senza
preoccuparsi dell'interazione con altri eventi. Certo non è molto chiaro cosa fare se elimino l'evento.
In generale, il fatto che l'evento sia "in corso" significa che è iniziato il lavoro preparatorio.

-a fine evento, chiusura e caricamento documentazione





Note per esame:


Gestione Compiti

UC Dettagliato:

I requisiti stanno tutti qui dentro, gli altri elaborati servono soltanto a rappresentarli
in modo più sintetico e formale, per facilità la progettazione, e la successiva implementazione
in codice, di un sistema che li rispetti.

Gli obbiettivi di questo UC sono due: fissare i compiti da svolgere in un servizio, raggruppandoli
in un documento detto foglio riepilogativo (passi 1 e 3 dell'uc dettagliato) e
poi assegnarli (passi 5-8), cioè associare ad ogni elemento del foglio (le prenotazioni sono
registrate anche lì!) almeno il turno e potenzialmente anche altro.
Compiti e prenotazioni venono registrate anche sul tabellone dei turni, che è sempre una vista dei
compiti, divisi per turno di assegnazione.

Noi immaginiamo il foglio riepilogativo come un recap di tutto ciò che serve per un servizio, quindi
ci stanno anche i compiti da non preparare, perchè comunque di base servirebbero.

Perchè non consentiamo l'eliminazione dei compiti "provenienti" dal menù??
Perchè non è richiesto da nessuna parte, oltre al fatto che il passo 2 lavora su compiti aggiunti
in sovrapiù, che sono logicamente diversi da quelli generati a partire dal menù
(in pratica quell'eccezione serve soltanto a garantire che cancellazione ed inserimento
al passo 2 abbiano lo stesso "scope").
A parlare dell'aggiunta di compiti fuori menù è chef Claudio.

Per far partire l'evento, attendiamo l'approvazione dei menù di tutti i servizi, perchè
esplicitamente richiesto dal testo.

Nota molta importante:
Le eccezioni sono errori concettuali, cioè intenzioni valide, che falliscono per cause legate alla logica di business.
NON devono invece essere segnalati gli errori nell'utilizzo del sistema (quello non è un punto di vista concettuale).

Modello di dominio:

Nell'evento, abbiamo durata e numero servizi perchè vengono citati in una user story e perchè
ha senso che una società di catering voglia una misura dello sforzo da fare per organizzare
un evento, sia in termini di giornate in cui il personale terrà occupato sia in termini di servizi da predisporre.

Abbiamo messo il numero di partecipanti in servizio: dalla unica user story in cui viene citato (Viola) non si capisce
bene se riguardi l'evento oppure il servizio. Ad ogni modo, Evento modella (anche) il concetto di scheda dell'evento, quindi
contiene anche cose relative ai servizi. Associandolo al servizio si ha un'info più precisa ed utile per la
pianificazione in un'azienda di catering.

Sempre per sapere quando organizzarsi, abbiamo riportato la data di inizio dell'evento, ma non quella di fine: vedere sopra 
perchè.

Dipendente Full Time ci serve perchè a prenotare potrebbero essere sia lo chef che l'organizzatore.

Un Evento potrebbe essere un Capofila, un'Occorrenza oppure nessuna delle due.
Le informazioni generali sulla ricorrenza sono contenute nell'evento capofila, ragion per cui quando lo eliminiamo dobbiamo "eleggerne" un'altro.
Il foglio riepilogativo è una composizione di compiti, quindi contiene le informazioni generali relative a questi ultimi e le assegnazioni.
Il tabellone è una composizione di turni, quindi contiene le informazioni generali relative a questi ultimi, più i compiti assegnati e le disponibilità.

Menù-composto da - Mansione di Cucina ci serve perchè in alcune operazioni (tipo la generazione del foglio riepilogativo) abbiamo
bisogno di recuperare rapidamento ciò che compone il menù.
È un'esempio di associazione derivata, perchè il suo contenuto è ricavabile dall'elenco di sezioni che formano il menù, dall'associazione menù-voce
e da quella voce-ricetta, però così il contratto risultato più compatto e semplice.
Inoltre, dato che il modello di dominio è un'ispirazione per il dcd, questa scelta si riverbera anche sul software, consentendo
un'implementazione più efficiente di alcune operazioni (anche se ovviamente comporta una maggior occupazione di spazio).
Perchè non contiene anche gli ingredienti? Perchè il vero "collo di bottiglia" è il recupero delle ricette che formano il menù: se riusciamo ad
arrivarci in un passo, diventa immediato ottenere gli ingredienti.
In pratica peggioreremmo notevolmente l'occupazione di spazio migliorando di poco la complessità tmeporale.

Non distinguiamo tra turno di cucina e di servizio, perchè quello eventualmente spetta ad altri uc (gestione turni, disponibilità), che
avranno più informazioni in merito.

La stessa mansione di cucina può essere svolta in più compiti diversi e, quindi, da più cuochi diversi, come richiesto dal testo.

SSD

Sono una rappresentazione, più sintetica e formale, dell'interazione tra attore e sistema, già espressa nell'uc dettagliato.
Infatti, per realizzarli, cerchiamo di far corrispondere ogni passo dell'uc ad un evento di sistema.
Il loop che contiene tutti i passi dal 2 all'8 serve perchè magari io non voglio cambiare foglio, ma eseguire quale operazione su diesso.
Non è strettamente necessario(si potrebbe chiudere e riaprire il foglio, ma è più veloce).


Contratti:

Le pre-condizioni generali devono corrispondere a quelle dell'uc.

Le pre-condizioni sono legate alle eccezioni dell'uc dettagliato, perchè bisogna evitare
fallimenti derivanti da errori concettuali.
Però c'è di più: dobbiamo infatti segnalare anche gli utilizzi errati del sistema (tipo una posizione non valida
nell'ordinamento del foglio riepilogativo).
Ricordare infatti che le pre-condizioni del contratto servono ad evitare il fallimento per mancanza di premesse logiche:
ne fanno parte tutte quelle condizioni in assenza delle quali l'utente non deve nemmeno sapere di poter fare l'operazione.
Servono a segnalare ai progettisti UI i casi in cui l'operazione non va nemmeno mostrata.
A livello business logic invece, si traducono in eccezioni, che segnalano che l'operazione non doveva essere chiamata.
Le guardia a livello di post-condizioni invece, esprimono quei casi in cui vogliamo notificare all'utente il perchè
non possa fare una certa operazione.
Si traducono in messaggi d'errore dell'ui e in eccezioni oppure valori di ritorno particolari a livello business logic.
Ovviamente i messaggi d'errore nei contratti non ci sono, perchè non hanno effetto sugli oggetti concettuali.
Per capire come esprimere ciascuna condizione, dobbiamo domandarci se
    -l'utente pensi di poter fare l'operazione, e quindi gli vada spiegato perchè non può
    (l'utente non deve mai trovarsi a non capire perchè non possa fare un'operazione)
    -il sistema ha le info che servono per nascondere un'operazione senza eseguirla.

Le post-condizioni si ottengono dettagliando e formalizzando la colonna sistema dell'uc dettagliato.
È un esempio di come l'uc dettagliato sia una panoramica generale del comportaemtno del sistema, poi
formalizzata da altri elaborati.

Contratto operazione 2a:
La verifica della non assegnazione del compito viene fatta a livello di guardia delle post-condizioni,
perchè magari poi l'utente non si ricorda di aver già assegnato il compito e dobbiamo spiegargli
perchè sia fallita l'operazione.

In tutti i contratti, la verifica dell'appartenenza del compito è una pre-condizione, perchè
se un compito non fa parte del foglio di lavoro non mi viene nemmeno in mente di fare un'operazione su di esso.
Nelle precondizioni ci sono anche tutte quelle proposizioni che servono a riferirsi ad elementi dello stato.


Disciplina di progettazione: 
Contiene attività ed elaborati che servono a definire l'architettura (moduli + struttura + interazione) del nostro sistema software.
La maggior parte dei progetti, ivi compreso il nostro, utilizza un'architettura a livelli.
Questi sono da intendersi come gruppi di moduli software, che interagiscono per fornire un servizio comune.
Ogni livello può servirsi dei servizi di quello sottostante, ignorandone però l'implementazione.
I vantaggi sono quelli soliti di un'architettura modulare:
    -scomposizione di un sistema complesso in blocchi, più facili da comprendere, progettare e manutenere
    -elevato potenziale di riuso: se il modello di servizio non cambia, posso sostituire il livello A con il B
    senza modificare gli altri
Insomma questa soluzione ci piace perchè applica il principio della progettazione modulare (pattern grasp high coesion e low coupling)
che ci porta a sfotware facile da comprendere, mantenere ed estendere.
 
La nostra architettura è composta da tre livelli:
    -ui: contiene tutto ciò che serve per l'interazione con l'utente, quindi i file fxml che definiscono le view
    ed i sorgenti java che definiscono i controller mvc.
    
    -domain: contiene tutti i moduli software che compongono il model mvc, cioè implementano la logica applicativa
    
    -technical services: strano che implementa servizi domain-agnostic, come login e persitenza, che di solito
    provengono da librerie di terze parti e non vengono sviluppate da zero.
  
I packages che formano ogni livello contengono tutti i moduli software che servono per implementare un UC: un ottimo
esempio di come UP sia una metodologia use-case driven.

L'interazione tra gli strati è più o meno la seguente:
    -l'utente interagisce con l'ui, generando gli eventi descritti nell'ssd
    -gli eventi sono notificati ai listener, che sono metodi del controller MVC, nei
    quali viene richiesta una certa computazione al domain
    -questa richiesta passa per il controller grasp, che fa da entry point al package,
    consentendo l'incapsulamento dei suoi dettagli implementativi ed architetturali,
    e riducendo la dipendenza tra ui e domain, e coordina l'esecuzione dell'operazione
    di sistema corrispondente all'evento, distribuendo la computazione necessaria tra varie
    classi, secondo il principio dell'assegnazione delle responsabilità, eseguita
    tramite pattern grasp.
    -una volta terminata l'esecuzione dell'operazione, il controller grasp notifica
    le eventuali variazioni di stato agli osservatori, tramite i metodi
    esposti da un'apposita interfaccia (pattern event-receiver).
    
Il DCD, un elaborato della disciplina di progettazione, su cui lavoriamo prevalentemente durante elaborazione e costruzione, serve
proprio a fissare l'architettura dello strato domain.
Tale architettura viene progettata usando l'OOD, quindi è composta da un'insieme di oggetti sfotware interagenti, la cui struttura ed i
cui legami sono mostrati nel dcd.
La princiaple fonte informativa per la progettazione del dcd è il modello di dominio: questo perchè le operazioni di sistema
sono descritte in termini di manipolazione di concetti della realtà, quindi è naturale che gli oggetti software
si ispirino a questi, pur non essendone una copia esatta. Inoltre, questo garantisce un salto rappresentazionale basso, che 
velocizza e semplifica la scrittura di sfotware.
Infine, le condizioni per applicare i pattern grasp vanno verificate tramite modello di dominio.
Il DCD viene progettato applicando i pattern GOF: cercarli del dcd.

I DSD sono sempre elaborati della disciplina di progettazione, su cui si lavora soprattutto durante elaborazione e costruzione.
Servono a descrivere l'implementazione delle operazioni di sistema. Dato che abbiamo applicato l'OOD, come previsto da UP, tali
operazioni vengono svolte tramite l'interazione tra oggetti software, che è ciò che in concreto viene rappresentato in un DSD.
Come detto, i compiti previsti da un'operazione di sistema vengono ripartiti tra gli oggetti in base alle responsabilità
che ognuno è in grado di assumersi. Per assegnarle efficacemente, utilizziamo i pattern grasp.

Vedere pattern event-receiver da slide polato.

Sia DCD che DSD sono rappresentati usando UML: un ottimo esempio di come sia applicabile tanto dal punto di vista concettuale che da quello software.

Vedere pre-condizioni uc

Cose da vedere


Vedere se Menù-composto da-mansione di cucina si possa trasformare in
Menù-composto da-ricetta

Togliere il riferimento al tabellone nei primi passi dell'uc.
